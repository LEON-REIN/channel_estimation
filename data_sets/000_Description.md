# 各数据集描述
------------------------------
## labels48_test.csv
- 描述  
  原始数据星座映射后的样本数据集. 用于各信道估计方式的横向测试.
  
- 内容  
  一个 CSV 表格文件, 共 1000 行 48 列, 共 48000 个四进制码元(int 类型).    
  每行表示一个 OFDM 符号要调制的 48 个数据码元, 共 1000 个样本.   
  调制阶数为 4, 每个数据码元为 {0, 1, 2, 3} 中的一个, 且均匀分布.  
  
- 读取  
  `np.loadtxt("./data_sets/labels48_test.csv", delimiter=",").astype(np.int)`

## labels48_train.csv
- 描述  
  原始数据星座映射后的样本数据集. 仅用于神经网络的训练.

- 内容  
  一个 CSV 表格文件, 共 10000 行 48 列, int 类型.    
  每行表示一个 OFDM 符号要调制的 48 个数据码元, 共 10000 个样本.   
  调制阶数为 4, 每个数据码元为 {0, 1, 2, 3} 中的一个, 且均匀分布.

- 读取  
  `original_symbols_train = np.load("./data_sets/labels48_train.npy")`

## labels64_test.csv
- 描述  
  将 `labels48_test.csv` 插入保护子载波, DC置零, 和导频.
  
- 内容  
  下标 [0:6] 共 6 个为置零子载波, 为 0;  
  下标 [6:11] 共 5 个为数据位置;  
  下标 [11] 是第一个导频, 为 3;  
  下标 [12:25] 共 13 个为数据位置;
  下标 [25] 是第二个导频, 为 3;  
  下标 [26:32] 共 6 个为数据位置;
  下标 [32] 为中间直流子载波置零, 为 0;  
  下标 [33:39] 共 6 个为数据位置;  
  下标 [39] 是第三个导频, 为 3;  
  下标 [40:53] 共 13 个为数据位置;  
  下标 [53] 是第四个导频, 为 3;  
  下标 [54:59] 共 5 个为数据位置;  
  下标 [59:64] 共 5 个为置零子载波, 为 0;  
  
- 额外数据位置(len = 16)  
  [0, 1, 2, 3, 4, 5, 11, 25, 32, 39, 53, 59, 60, 61, 62, 63]
  
- 导频位置  
  [11, 25, 39, 53]
  
- 有效数据码元位置  
  [6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29, 30, 31, 
  33, 34, 35, 36, 37, 38, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58]


- 读取  
  `np.loadtxt("./data_sets/labels64.csv", delimiter=",").astype(np.int)`

- 注意  
  将此文件转为复数后, 需要根据多进制调制方式对模值进行归一化!!
  
## labels64_train.npy
- 描述  
  基本同 `labels64_test.csv`, 除了行数为 10000.


## labels64_onehot_test.npy  
- 描述  
  专用于神经网络的标签数据, 由 onehot 向量组成.    

- 内容  
  1000 行 64*4=256 列; 任意某行的 256 个元素中, 每 4 个为一组 onehot 编码.  
  
- 读取  
  `original_64_onehot = np.load("./data_sets/labels64_onehot.npy")`  

## labels64_onehot_train.npy
- 描述  
  基本同上, 除了行数为 10000.


## after_cp80_test.npy
- 描述  
  将并行数据进行 OFDM 调制.   
  将并行数据, 先进行 IFFT 运算, 再加入循环前缀, 生成待发送的复包络的采样值(DAC前).  
  
- 内容  
  1000 行 80 列, 每个元素为 complex128 格式, 每一行的前 16 列为最后 16 列的复制;   
  后 64 列为输入转换为复数后的 IFFT.
  
- 读取  
  `after_cp = np.load("./data_sets/after_cp80.npy")`

## after_cp80_train.npy
- 描述  
  基本同上, 除了行数为 10000.

## norm_amp.mat, norm_delay_ms.mat
- 描述  
  是BELLHOP模型生成的复数信道冲激响应, 已经经过归一化处理.   
  此二者包含了非零冲激产生的时间, 和其对应的复数冲激幅度


## after_channel80_test.npy
- 描述  
  将发送的复包络卷积转为串行后线性卷积多径信道的复数冲激响应, 再加上指定信噪比的复数高斯白噪声.  
  简略了同步操作. 又由于不引入
  
  
- 内容  
  1000 行 80 列, 每个元素为 complex128 格式.

- 读取  
  `after_channel = np.load("./data_sets/after_channel80.npy")`


## after_channel80_train.npy
- 描述
  基本同上, 除了行数为 10000.

## after_fft64_test.npy
- 描述  
  去掉信道传来的每一个 OFDM 符号的前缀, 再进行 OFDM 解调, 以用于均衡.  
  
- 内容  
  1000 行 64 列, 每个元素为 complex128 格式. 
  
- 读取  
  `after_fft64 = np.load("./data_sets/after_fft64.npy")`

## after_fft64_train.npy
- 描述  
  基本同上, 除了行数为 10000.
  


